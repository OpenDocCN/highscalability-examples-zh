# Mailinator 架构

> 原文： [http://highscalability.com/blog/2008/1/24/mailinator-architecture.html](http://highscalability.com/blog/2008/1/24/mailinator-architecture.html)

**更新：**在[中进行应用搜索的有趣探索，如何每秒搜索 185 封电子邮件中的单词“ pen1s”](http://mailinator.blogspot.com/2008/01/how-to-search-for-word-pen1s-in-185.html) 。 如果 indexOf 没有减少，您会更加努力。

曾经有一个醉酒的朋友启发您创建了首个受到数百万人喜爱，被数千人颠覆的互联网服务，同时每年通过[欺骗](http://www.flickr.com/photos/arcticstylings/814612466)处理超过 12 亿封电子邮件 ]旧服务器？ 这就是 Paul Tyma 来建立 Mailinator 的方式。

Mailinator 是一项免费的无设置 Web 服务，用于通过创建一次性注册电子邮件地址来阻止恶意垃圾邮件发送者。 如果您不给网站提供真实的电子邮件地址，那么他们就不会向您发送垃圾邮件。 他们反而对 Mailinator 发出垃圾邮件：-)

我喜欢从角度出发进行设计，而 Mailinator 有一个巨大的挑战：性能第一，第二和最后。 为什么？ 因为 Mailinator 是免费的，所以 Paul 可以展示他对设计的不同看法。 竞争对手购买大型 Iron 来处理负荷时，Paul 却提出了一个大主意：选择正确的问题并设计一个适合该问题的设计。 不再。 不少 结果是一个完美的系统架构十四行诗，在形式的约束之内美。

Mailinator 作为垃圾邮件破坏超级英雄如何开展工作？

网站：http：//mailinator.com/

## 信息来源

*   [Mailinator 的体系结构](http://mailinator.blogspot.com/2007/01/architecture-of-mailinator.html)*   [Mailinator's 2006 Stats](http://mailinator.blogspot.com/2007/02/mailinators-2006-stats.html)

    ## 该平台

    *   的 Linux*   雄猫*   Java

    ## 统计资料

    *   2007 年将处理大约 12.9 亿封电子邮件。2006 年为 450.74 百万封电子邮件。2005 年为 280.68 百万封电子邮件。*   峰值速率为每天 650 万封电子邮件或 4513 个/分钟或 75 个/秒。*   Mailinator 运行在非常适度的计算机上，该计算机具有 AMD 2Ghz Athlon 处理器，1GB RAM（使用的内存更少）和低性能的 80G IDE 硬盘驱动器。 而且机器根本不是很忙。*   即使在持续的垃圾邮件攻击和高峰值负载下，Mailinator 也可以无人值守运行数月，并且很少丢失电子邮件。

    ## 架构

    *   拥有免费系统意味着该系统不一定是完美的。 因此，设计目标是：
    -设计一个系统，该系统重视生存，甚至是用户。 生存是关键，因为 Mailinator 必须每天抵御攻击。
    -为用户提供 99.99％的正常运行时间和准确性。 更高的正常运行时间目标将是不切实际且成本高昂的。 而且由于该服务是免费的，因此这对于用户来说只是游戏规则的一部分。
    -支持以下服务模型：用户注册某些内容，转到 Mailinator，单击订阅链接，然后忘记它。 这意味着电子邮件不必永久存储在磁盘上。 电子邮件可以驻留在 RAM 中，因为它是临时的（3-4 小时）。 如果您想要一个真实的邮箱，请使用其他服务。*   电子邮件处理的原始流程是：
    -Sendmail 在单个磁盘邮箱中接收到电子邮件。
    -基于 Java 的 Mailinator 使用 IMAP 和/或 POP（随时间变化）抓取电子邮件并将其删除。
    -系统随后将所有电子邮件加载到内存中，然后将其放置在那里。
    -达到 20,000 个内存限制后，最早的电子邮件便被推出。*   原始体系结构运行良好：
    -它稳定并且一次可以使用几个月。
    -它几乎使用了所有 1GB 的 RAM。
    -每天收到的电子邮件速率开始超过 800,000 时出现问题。 由于 Mailinator 和电子邮件子系统之间的磁盘争用，系统崩溃了。*   新架构：
    -想法是删除磁盘上的路径，这是通过完整的系统重写来完成的。
    -Web 应用程序，电子邮件服务器和所有电子邮件存储都在一个 JVM 中运行。
    -Sendmail 被替换为自定义的 SMTP 服务器。 由于 Mailinator 的性质，因此不需要完整的 SMTP 服务器。 Mailinator 不需要发送电子邮件。 它的主要职责是尽快接受或拒绝电子邮件。 这是分层的缺点。 分层通常是扩展的关键策略，但由于关键决策最好在堆栈的最高级别进行处理，因此会降低性能。 因此，当许多 RAM 和周期窃取操作已经完成时，工作流将流经系统，仅在较低层进行转储。 因此，决定使用定制 SMTP 服务器是一个有趣而勇敢的决定。 此时大多数人只会添加更多硬件。 他们不会错，但是看到这条路也很有趣。 也许有了更多 [DOM 和 AOP](http://radio.weblogs.com/0103955/categories/stupidHumanProgramming/2007/06/20.html#a244) 这样的体系结构，我们可以展平堆栈并在需要时获得更好的性能。
    -现在 Mailinator 直接接收电子邮件，进行解析并将其存储到内存中。 磁盘被完全绕过，并且磁盘仍然相当空闲。
    -系统关闭时，电子邮件将写入磁盘，因此可以在启动时重新加载它们。
    -记录已关闭，以消除传票的风险。 执行日志记录时，日志数据是成批写入的，因此在一次磁盘写入中将写入数千行日志。 这样可以最大程度地减少磁盘争用，否则会丢失有用的诊断信息。
    -系统使用少于 300 个线程。 不需要更多。
    -到达后，每封电子邮件都会通过过滤器系统，如果所有过滤器都通过，则会存储在 RAM 中。
    -每个收件箱仅限于 10 封电子邮件，因此流行的收件箱，例如 [[受电子邮件保护]](/cdn-cgi/l/email-protection) ，无法使系统崩溃。
    -传入的电子邮件不得超过 100k，所有附件都将立即被丢弃。 这样可以节省 RAM。*   电子邮件在 RAM 中压缩：
    -由于从未查看过 99％的电子邮件，因此压缩电子邮件可以节省 RAM。 当有人看着它们时，它们只有
    被解压缩。
    -Mailinator 可以使用不到 300MB 的内存在 RAM 中存储约 80,000 封电子邮件，而原始设计中的 1GB RAM 中存储了 20,000 封电子邮件。
    -使用此池，平均电子邮件寿命约为 3-4 小时。
    -可能有 200,000 封电子邮件可以容纳在内存中，但是并没有真正的需求。
    -这是我喜欢的设计细节之一，因为它基于真实的应用程序使用模式。 RAM 很珍贵，而 CPU 却不是，所以知道大多数情况下您不必将 CPU 命中两次，使用压缩来节省 RAM 却以 CPU 为代价。*   Mailinator 不保证匿名和隐私：
    -没有隐私。 任何人都可以随时阅读任何收件箱。
    -放宽这些约束，同时又令人震惊，使设计更加简单。
    -对于用户而言，这很简单，因为不需要注册。 当网站要求您提供电子邮件地址时，您只需输入一个 mailinator 地址即可。 您无需创建单独的帐户。 键入电子邮件地址可以有效地创建 mailinator 帐户。 简单。
    -在实践中，用户仍然可以获得高度的隐私。*   可生存性的目标导致积极的垃圾邮件过滤。
    -Mailinator 没有针对 SPAM 的任何内容，但是由于 SPAM 太多，因此在威胁到系统正常运行时必须将其过滤掉。
    -这导致以下规则：如果您做任何事情（无论是否发垃圾邮件）都开始影响系统，则您的电子邮件将被拒绝，您可能会被锁定。*   要被接受，电子邮件必须通过以下过滤链：
    -退回：所有退回的电子邮件都会被丢弃。
    -IP：丢弃了来自单个 IP 的过多电子邮件
    -主题：丢弃了有关同一主题的过多电子邮件
    -便笺：包含了表示仇恨或犯罪或仅是彻头彻尾的讨厌表情的主题 。*   从单个 IP 地址
    中幸存的电子邮件泛滥-AgingHashmap 用于过滤来自特定 IP 地址的垃圾邮件发送者。 当电子邮件到达 IP 地址时，会将 IP 放入地图中，并为所有后续电子邮件增加计数器。
    -在一段时间内没有电子邮件后，计数器将被清除。
    -当发件人达到电子邮件计数阈值时，将阻止该发件人。 这样可以防止发件人淹没系统。
    -许多系统使用这种逻辑来保护各种资源，例如注释。 您可以将 memcached 用于分布式系统中的相同目的。*   防范僵尸攻击：
    -垃圾邮件可以从称为 IP 僵尸网络的不同 IP 地址的大型坐标集中发送。 相同的消息是从数千个不同的 IP 地址发送的，因此用于阻止来自单个 IP 地址的电子邮件的技术还不够。
    -这种过滤比 IP 阻止要复杂一些，因为您必须解析足够多的
    电子邮件才能获得主题行，而匹配主题字符串则需要更多的资源。
    -当 2 分钟之内有 20 封电子邮件发送同一主题时，所有带有该主题的电子邮件将被禁止 1 小时。
    -有趣的是，并没有永远禁止主题，因为这意味着 Mailinator 将不得不永远跟踪主题，并且系统设计固有地是瞬态的。 我认为这很聪明。 通过一些“不好的”电子邮件，通过系统变得简单得多，因为不必管理任何持久性列表，并且该列表肯定会成为瓶颈。 一个具有更严格的 SPAM 过滤目标的系统将不得不创建一个更加复杂且不那么健壮的体系结构。
    -仅有 9％的电子邮件被此过滤器阻止。
    -从我的阅读中，Mailinator 仅针对 IP 和主题进行过滤，因此不必阅读电子邮件正文即可接受或拒绝电子邮件。 当大多数电子邮件将被拒绝时，这可以最大程度地减少资源使用。*   为减轻 DOS 攻击的危险，请执行以下操作：
    -丢弃在特定时间段内保持沉默的所有连接。
    -Mailinator 会非常缓慢地（例如 10 或 20 或 30 秒）将回复发送给电子邮件发件人，即使是非常少量的数据也是如此。 这会减慢试图尽快发送垃圾邮件的垃圾邮件发送者的速度，并可能使他们重新考虑再次向该地址发送电子邮件。 繁忙时段的等待时间减少了，因此电子邮件不会丢失。

    ## 得到教训

    *   **完善是陷阱**。 驱动器使 100％的一切变得更加复杂。 如果您去过那些会议，您就会知道他们的样子。 哦，我们不能这样或那样做，因为发生错误的可能性为 0.01％。 而是问：你会多么不完美，不够好？

    *   **扔掉的东西与**存放的东西一样重要。 我们对如何设计系统有许多先入之见。 我们理所当然地认为您需要横向扩展，几天后需要访问电子邮件，并且必须为每个人提供
    私人帐户。 但是您真的需要这些东西吗？ 你能扔什么？

    *   **了解系统的用途并进行相应设计**。 所有人都拥有一切意味着您对任何人都不是。 将电子邮件保留很短的时间，允许一些 SPAM 通过，并接受少于 100％的正常运行时间，这将为该系统创建一个强大的愿景，从而有助于在各个领域推动设计。 如果您对系统的含义和需求有非常深刻的了解，则只能构建自己的 SMTP 服务器。 我知道这绝不会成为我的主意。 我会增加更多的硬件。

    *   **对于常见情况，在提交资源**之前快速失败。 很高比例的电子邮件被拒绝，因此在堆栈中尽早拒绝它是有意义的，以最大程度地减少完成任务的资源。 找出如何尽快使经常发生故障的物品短路。 这很重要，并且经常被忽视。

    *   **效率通常意味着您自己建立**。 现成的工具往往可以完成全部工作。 如果您只需要完成部分工作，则可以编写运行速度更快的自定义组件。

    *   **自适应地忘记**。 有点失败是可以的。 不需要永远记住所有被阻止的 IP 地址。 让块决策从本地数据而不是全局状态开始。 这是功能强大且简单而强大的体系结构。

    *   **Java 不必太慢**。 说够了。

    *   **避开磁盘**。 许多应用程序需要使用磁盘，但是磁盘始终是瓶颈。 您可以使用其他创意策略在磁盘周围进行设计吗？

    *   **限制资源使用量**。 放入约束，例如收件箱大小，这将使您的系统无法控制地突刺。 必须在资源有限的情况下避免无限制的资源使用。

    *   **压缩数据**。 尝试节省 RAM 时，压缩可能是一大胜利
    。 我发现使用压缩的开销很少，而内存使用量却下降了一半以上。 如果您是在本地进行通信，则只需让客户端对数据进行编码并保持编码状态即可。 构建 API 无需解码完整的消息即可访问数据。

    *   **使用固定大小的资源池来处理负载**。 许多应用程序无法控制资源的使用，例如内存，如果使用过多，它们就会崩溃。 要创建一个真正强大的系统，请修复您的资源，并在这些资源已满时放弃工作。 您可以老化资源，给予优先访问权，给予公平访问权或使用任何其他逻辑来仲裁资源访问权，但是由于资源将受到限制，因此您将承受负载。

    *   **如果不保留数据，则不会传唤**。 由于 Mailinator 不存储电子邮件或在磁盘上登录日志，因此可以进行传票。

    *   **使用您所知道的**。 我们已经看过几次这一课了。 保罗比其他任何人都更了解 Java，因此他使用了 Java，使其得以运行，然后他完成了工作。

    *   **查找您自己的 Mailinators** 。 当然，Mailinator 是一个小型系统。 在大型系统中，这只是一个小功能，但是您的系统由许多 Mailinator 大小的项目组成。 如果您开发了诸如 Mailinator 之类的
    ，该怎么办？

    *   **KISS 存在，尽管很少见**。 总是谈论保持简单，但是我们很少显示真实的例子。 这主要是因为您的方法很复杂，而我的方法却很简单，因为这是我的方法。 Mailinator 是简单设计的一个很好的例子。

    *   **健壮性是体系结构**的功能。 要创建有效利用内存并能抵御大量垃圾邮件攻击的设计，需要一种能够查看整个堆栈的架构方法。

    ## 相关文章

    *   [PlentyOfFish](http://highscalability.com/plentyoffish-architecture) 拥护直截了当的裸露骨头。*   [Varnish](http://highscalability.com/links/goto/117/) 巧妙地使用 OS 功能来找到令人难以置信的性能。*   [ThemBid](http://highscalability.com/thembid-architecture) 优雅地将开源组件组合在一起。

很棒的阅读。

这属于“我曾想过的想法”的构想。

我不知道他如何获得资助？

[http://codershangout.com](http://codershangout.com)
编码人员可以进行视频群聊的地方！

有资金吗？ 自掏腰包。 这是他的爱好。